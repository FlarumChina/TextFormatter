<?php

namespace s9e\TextFormatter\Tests;

use DOMDocument,
    ReflectionMethod,
    s9e\TextFormatter\Tests\Test,
    s9e\TextFormatter\Parser,
    s9e\TextFormatter\PluginConfig,
    s9e\TextFormatter\PluginParser;

include_once __DIR__ . '/Test.php';

/**
* @covers s9e\TextFormatter\Parser
*/
class ParserTest extends Test
{
	public function setUp()
	{
		parent::setUp();
		include_once __DIR__ . '/../src/Parser.php';
	}

	public function tearDown()
	{
		if (!empty($this->restoreHttpWrapper))
		{
			stream_wrapper_restore('http');
		}
	}

	protected function assertAttributeIsValid($attrConf, $attrVal, $expectedVal = null, $expectedLog = array())
	{
		$expectedLog += array('error' => null);
		$this->assertAttributeValidity($attrConf, $attrVal, $expectedVal, true, $expectedLog);
	}

	protected function assertAttributeIsInvalid($attrConf, $attrVal, $expectedVal = null, $expectedLog = array())
	{
		$this->assertAttributeValidity($attrConf, $attrVal, $expectedVal, false, $expectedLog);
	}

	protected function assertAttributeValidity($attrConf, $attrVal, $expectedVal, $valid, $expectedLog)
	{
		if (!is_array($attrConf))
		{
			$attrConf = array('type' => $attrConf);
		}

		$filtersConfig = $this->cb->getFiltersConfig();

		if (!isset($filtersConfig[$attrConf['type']]))
		{
			$filtersConfig[$attrConf['type']] = array();
		}

		$actualVal = Parser::filter(
			$attrVal,
			$attrConf,
			$filtersConfig[$attrConf['type']],
			$this->parser
		);

		$this->assertArrayMatches($expectedLog, $this->parser->getLog());

		if ($valid)
		{
			if (!isset($expectedVal))
			{
				$expectedVal = $attrVal;
			}

			$this->assertEquals($expectedVal, $actualVal);
		}
		else
		{
			$this->assertFalse($actualVal, 'Invalid attrVal did not return false');
		}
	}

	protected function assertHtmlStringKindOfEqualsHtmlString($expectedHtml, $actualHtml)
	{
		$expectedDOM = new DOMDocument;
		$expectedDOM->loadHTML($expectedHtml);

		$actualDOM = new DOMDocument;
		$actualDOM->loadHTML($actualHtml);

		$this->assertXmlStringEqualsXmlString(
			$actualDOM->saveXML(),
			$expectedDOM->saveXML()
		);
	}

	protected function fakeRedirect($from, $to)
	{
		$this->restoreHttpWrapper = true;

		stream_wrapper_unregister('http');
		stream_wrapper_register('http', __NAMESPACE__ . '\\FakeRedirect');

		FakeRedirect::$redirectTo = array($from => $to);

		$i = 1;
		while (++$i < func_num_args())
		{
			$from = $to;
			$to = func_get_arg($i);

			FakeRedirect::$redirectTo[$from] = $to;
		}
	}

	//==========================================================================
	// General stuff
	//==========================================================================

	/**
	* @test
	*/
	public function Ouput_is_UTF8()
	{
		$this->assertContains(
			'Ü',
			$this->parser->parse('Ü')
		);
	}

	//==========================================================================
	// Filters
	//==========================================================================

	// Start of content generated by ../scripts/patchParserTest.php
	/**
	* @test
	* @testdox Filter "int" accepts strings made entirely of digits
	*/
	public function Filter_int_accepts_strings_made_entirely_of_digits()
	{
		$this->assertAttributeIsValid('int', '123');
	}

	/**
	* @test
	* @testdox Filter "int" rejects strings that starts with digits
	*/
	public function Filter_int_rejects_strings_that_starts_with_digits()
	{
		$this->assertAttributeIsInvalid('int', '123abc');
	}

	/**
	* @test
	* @testdox Filter "int" accepts integers
	*/
	public function Filter_int_accepts_integers()
	{
		$this->assertAttributeIsValid('int', 123);
	}

	/**
	* @test
	* @testdox Filter "int" rejects numbers that start with a zero
	*/
	public function Filter_int_rejects_numbers_that_start_with_a_zero()
	{
		$this->assertAttributeIsInvalid('int', '0123');
	}

	/**
	* @test
	* @testdox Filter "int" accepts negative numbers
	*/
	public function Filter_int_accepts_negative_numbers()
	{
		$this->assertAttributeIsValid('int', '-123');
	}

	/**
	* @test
	* @testdox Filter "int" rejects decimal numbers
	*/
	public function Filter_int_rejects_decimal_numbers()
	{
		$this->assertAttributeIsInvalid('int', '12.3');
	}

	/**
	* @test
	* @testdox Filter "int" rejects floats
	*/
	public function Filter_int_rejects_floats()
	{
		$this->assertAttributeIsInvalid('int', 12.3);
	}

	/**
	* @test
	* @testdox Filter "int" rejects numbers too big for the PHP integer type
	*/
	public function Filter_int_rejects_numbers_too_big_for_the_PHP_integer_type()
	{
		$this->assertAttributeIsInvalid('int', '9999999999999999999');
	}

	/**
	* @test
	* @testdox Filter "int" rejects positive numbers in E notation
	*/
	public function Filter_int_rejects_positive_numbers_in_E_notation()
	{
		$this->assertAttributeIsInvalid('int', '12e3');
	}

	/**
	* @test
	* @testdox Filter "int" rejects negative numbers in E notation
	*/
	public function Filter_int_rejects_negative_numbers_in_E_notation()
	{
		$this->assertAttributeIsInvalid('int', '-12e3');
	}

	/**
	* @test
	* @testdox Filter "int" rejects positive numbers in E notation with a negative exponent
	*/
	public function Filter_int_rejects_positive_numbers_in_E_notation_with_a_negative_exponent()
	{
		$this->assertAttributeIsInvalid('int', '12e-3');
	}

	/**
	* @test
	* @testdox Filter "int" rejects negative numbers in E notation with a negative exponent
	*/
	public function Filter_int_rejects_negative_numbers_in_E_notation_with_a_negative_exponent()
	{
		$this->assertAttributeIsInvalid('int', '-12e-3');
	}

	/**
	* @test
	* @testdox Filter "int" rejects numbers in hex notation
	*/
	public function Filter_int_rejects_numbers_in_hex_notation()
	{
		$this->assertAttributeIsInvalid('int', '0x123');
	}

	/**
	* @test
	* @testdox Filter "integer" accepts strings made entirely of digits
	*/
	public function Filter_integer_accepts_strings_made_entirely_of_digits()
	{
		$this->assertAttributeIsValid('integer', '123');
	}

	/**
	* @test
	* @testdox Filter "integer" rejects strings that starts with digits
	*/
	public function Filter_integer_rejects_strings_that_starts_with_digits()
	{
		$this->assertAttributeIsInvalid('integer', '123abc');
	}

	/**
	* @test
	* @testdox Filter "integer" accepts integers
	*/
	public function Filter_integer_accepts_integers()
	{
		$this->assertAttributeIsValid('integer', 123);
	}

	/**
	* @test
	* @testdox Filter "integer" rejects numbers that start with a zero
	*/
	public function Filter_integer_rejects_numbers_that_start_with_a_zero()
	{
		$this->assertAttributeIsInvalid('integer', '0123');
	}

	/**
	* @test
	* @testdox Filter "integer" accepts negative numbers
	*/
	public function Filter_integer_accepts_negative_numbers()
	{
		$this->assertAttributeIsValid('integer', '-123');
	}

	/**
	* @test
	* @testdox Filter "integer" rejects decimal numbers
	*/
	public function Filter_integer_rejects_decimal_numbers()
	{
		$this->assertAttributeIsInvalid('integer', '12.3');
	}

	/**
	* @test
	* @testdox Filter "integer" rejects floats
	*/
	public function Filter_integer_rejects_floats()
	{
		$this->assertAttributeIsInvalid('integer', 12.3);
	}

	/**
	* @test
	* @testdox Filter "integer" rejects numbers too big for the PHP integer type
	*/
	public function Filter_integer_rejects_numbers_too_big_for_the_PHP_integer_type()
	{
		$this->assertAttributeIsInvalid('integer', '9999999999999999999');
	}

	/**
	* @test
	* @testdox Filter "integer" rejects positive numbers in E notation
	*/
	public function Filter_integer_rejects_positive_numbers_in_E_notation()
	{
		$this->assertAttributeIsInvalid('integer', '12e3');
	}

	/**
	* @test
	* @testdox Filter "integer" rejects negative numbers in E notation
	*/
	public function Filter_integer_rejects_negative_numbers_in_E_notation()
	{
		$this->assertAttributeIsInvalid('integer', '-12e3');
	}

	/**
	* @test
	* @testdox Filter "integer" rejects positive numbers in E notation with a negative exponent
	*/
	public function Filter_integer_rejects_positive_numbers_in_E_notation_with_a_negative_exponent()
	{
		$this->assertAttributeIsInvalid('integer', '12e-3');
	}

	/**
	* @test
	* @testdox Filter "integer" rejects negative numbers in E notation with a negative exponent
	*/
	public function Filter_integer_rejects_negative_numbers_in_E_notation_with_a_negative_exponent()
	{
		$this->assertAttributeIsInvalid('integer', '-12e-3');
	}

	/**
	* @test
	* @testdox Filter "integer" rejects numbers in hex notation
	*/
	public function Filter_integer_rejects_numbers_in_hex_notation()
	{
		$this->assertAttributeIsInvalid('integer', '0x123');
	}

	/**
	* @test
	* @testdox Filter "uint" accepts strings made entirely of digits
	*/
	public function Filter_uint_accepts_strings_made_entirely_of_digits()
	{
		$this->assertAttributeIsValid('uint', '123');
	}

	/**
	* @test
	* @testdox Filter "uint" rejects strings that starts with digits
	*/
	public function Filter_uint_rejects_strings_that_starts_with_digits()
	{
		$this->assertAttributeIsInvalid('uint', '123abc');
	}

	/**
	* @test
	* @testdox Filter "uint" accepts integers
	*/
	public function Filter_uint_accepts_integers()
	{
		$this->assertAttributeIsValid('uint', 123);
	}

	/**
	* @test
	* @testdox Filter "uint" rejects numbers that start with a zero
	*/
	public function Filter_uint_rejects_numbers_that_start_with_a_zero()
	{
		$this->assertAttributeIsInvalid('uint', '0123');
	}

	/**
	* @test
	* @testdox Filter "uint" rejects negative numbers
	*/
	public function Filter_uint_rejects_negative_numbers()
	{
		$this->assertAttributeIsInvalid('uint', '-123');
	}

	/**
	* @test
	* @testdox Filter "uint" rejects decimal numbers
	*/
	public function Filter_uint_rejects_decimal_numbers()
	{
		$this->assertAttributeIsInvalid('uint', '12.3');
	}

	/**
	* @test
	* @testdox Filter "uint" rejects floats
	*/
	public function Filter_uint_rejects_floats()
	{
		$this->assertAttributeIsInvalid('uint', 12.3);
	}

	/**
	* @test
	* @testdox Filter "uint" rejects numbers too big for the PHP integer type
	*/
	public function Filter_uint_rejects_numbers_too_big_for_the_PHP_integer_type()
	{
		$this->assertAttributeIsInvalid('uint', '9999999999999999999');
	}

	/**
	* @test
	* @testdox Filter "uint" rejects positive numbers in E notation
	*/
	public function Filter_uint_rejects_positive_numbers_in_E_notation()
	{
		$this->assertAttributeIsInvalid('uint', '12e3');
	}

	/**
	* @test
	* @testdox Filter "uint" rejects negative numbers in E notation
	*/
	public function Filter_uint_rejects_negative_numbers_in_E_notation()
	{
		$this->assertAttributeIsInvalid('uint', '-12e3');
	}

	/**
	* @test
	* @testdox Filter "uint" rejects positive numbers in E notation with a negative exponent
	*/
	public function Filter_uint_rejects_positive_numbers_in_E_notation_with_a_negative_exponent()
	{
		$this->assertAttributeIsInvalid('uint', '12e-3');
	}

	/**
	* @test
	* @testdox Filter "uint" rejects negative numbers in E notation with a negative exponent
	*/
	public function Filter_uint_rejects_negative_numbers_in_E_notation_with_a_negative_exponent()
	{
		$this->assertAttributeIsInvalid('uint', '-12e-3');
	}

	/**
	* @test
	* @testdox Filter "uint" rejects numbers in hex notation
	*/
	public function Filter_uint_rejects_numbers_in_hex_notation()
	{
		$this->assertAttributeIsInvalid('uint', '0x123');
	}

	/**
	* @test
	* @testdox Filter "number" accepts strings made entirely of digits
	*/
	public function Filter_number_accepts_strings_made_entirely_of_digits()
	{
		$this->assertAttributeIsValid('number', '123');
	}

	/**
	* @test
	* @testdox Filter "number" rejects strings that starts with digits
	*/
	public function Filter_number_rejects_strings_that_starts_with_digits()
	{
		$this->assertAttributeIsInvalid('number', '123abc');
	}

	/**
	* @test
	* @testdox Filter "number" accepts integers
	*/
	public function Filter_number_accepts_integers()
	{
		$this->assertAttributeIsValid('number', 123);
	}

	/**
	* @test
	* @testdox Filter "number" accepts numbers that start with a zero
	*/
	public function Filter_number_accepts_numbers_that_start_with_a_zero()
	{
		$this->assertAttributeIsValid('number', '0123');
	}

	/**
	* @test
	* @testdox Filter "number" rejects negative numbers
	*/
	public function Filter_number_rejects_negative_numbers()
	{
		$this->assertAttributeIsInvalid('number', '-123');
	}

	/**
	* @test
	* @testdox Filter "number" rejects decimal numbers
	*/
	public function Filter_number_rejects_decimal_numbers()
	{
		$this->assertAttributeIsInvalid('number', '12.3');
	}

	/**
	* @test
	* @testdox Filter "number" rejects floats
	*/
	public function Filter_number_rejects_floats()
	{
		$this->assertAttributeIsInvalid('number', 12.3);
	}

	/**
	* @test
	* @testdox Filter "number" accepts numbers too big for the PHP integer type
	*/
	public function Filter_number_accepts_numbers_too_big_for_the_PHP_integer_type()
	{
		$this->assertAttributeIsValid('number', '9999999999999999999');
	}

	/**
	* @test
	* @testdox Filter "number" rejects positive numbers in E notation
	*/
	public function Filter_number_rejects_positive_numbers_in_E_notation()
	{
		$this->assertAttributeIsInvalid('number', '12e3');
	}

	/**
	* @test
	* @testdox Filter "number" rejects negative numbers in E notation
	*/
	public function Filter_number_rejects_negative_numbers_in_E_notation()
	{
		$this->assertAttributeIsInvalid('number', '-12e3');
	}

	/**
	* @test
	* @testdox Filter "number" rejects positive numbers in E notation with a negative exponent
	*/
	public function Filter_number_rejects_positive_numbers_in_E_notation_with_a_negative_exponent()
	{
		$this->assertAttributeIsInvalid('number', '12e-3');
	}

	/**
	* @test
	* @testdox Filter "number" rejects negative numbers in E notation with a negative exponent
	*/
	public function Filter_number_rejects_negative_numbers_in_E_notation_with_a_negative_exponent()
	{
		$this->assertAttributeIsInvalid('number', '-12e-3');
	}

	/**
	* @test
	* @testdox Filter "number" rejects numbers in hex notation
	*/
	public function Filter_number_rejects_numbers_in_hex_notation()
	{
		$this->assertAttributeIsInvalid('number', '0x123');
	}

	/**
	* @test
	* @testdox Filter "float" accepts strings made entirely of digits
	*/
	public function Filter_float_accepts_strings_made_entirely_of_digits()
	{
		$this->assertAttributeIsValid('float', '123');
	}

	/**
	* @test
	* @testdox Filter "float" rejects strings that starts with digits
	*/
	public function Filter_float_rejects_strings_that_starts_with_digits()
	{
		$this->assertAttributeIsInvalid('float', '123abc');
	}

	/**
	* @test
	* @testdox Filter "float" accepts integers
	*/
	public function Filter_float_accepts_integers()
	{
		$this->assertAttributeIsValid('float', 123);
	}

	/**
	* @test
	* @testdox Filter "float" accepts numbers that start with a zero
	*/
	public function Filter_float_accepts_numbers_that_start_with_a_zero()
	{
		$this->assertAttributeIsValid('float', '0123', '123');
	}

	/**
	* @test
	* @testdox Filter "float" accepts negative numbers
	*/
	public function Filter_float_accepts_negative_numbers()
	{
		$this->assertAttributeIsValid('float', '-123');
	}

	/**
	* @test
	* @testdox Filter "float" accepts decimal numbers
	*/
	public function Filter_float_accepts_decimal_numbers()
	{
		$this->assertAttributeIsValid('float', '12.3');
	}

	/**
	* @test
	* @testdox Filter "float" accepts floats
	*/
	public function Filter_float_accepts_floats()
	{
		$this->assertAttributeIsValid('float', 12.3);
	}

	/**
	* @test
	* @testdox Filter "float" accepts numbers too big for the PHP integer type
	*/
	public function Filter_float_accepts_numbers_too_big_for_the_PHP_integer_type()
	{
		$this->assertAttributeIsValid('float', '9999999999999999999', '1.0E+19');
	}

	/**
	* @test
	* @testdox Filter "float" accepts positive numbers in E notation
	*/
	public function Filter_float_accepts_positive_numbers_in_E_notation()
	{
		$this->assertAttributeIsValid('float', '12e3');
	}

	/**
	* @test
	* @testdox Filter "float" accepts negative numbers in E notation
	*/
	public function Filter_float_accepts_negative_numbers_in_E_notation()
	{
		$this->assertAttributeIsValid('float', '-12e3');
	}

	/**
	* @test
	* @testdox Filter "float" accepts positive numbers in E notation with a negative exponent
	*/
	public function Filter_float_accepts_positive_numbers_in_E_notation_with_a_negative_exponent()
	{
		$this->assertAttributeIsValid('float', '12e-3');
	}

	/**
	* @test
	* @testdox Filter "float" accepts negative numbers in E notation with a negative exponent
	*/
	public function Filter_float_accepts_negative_numbers_in_E_notation_with_a_negative_exponent()
	{
		$this->assertAttributeIsValid('float', '-12e-3');
	}

	/**
	* @test
	* @testdox Filter "float" rejects numbers in hex notation
	*/
	public function Filter_float_rejects_numbers_in_hex_notation()
	{
		$this->assertAttributeIsInvalid('float', '0x123');
	}
	// End of content generated by ../scripts/patchParserTest.php

	/**
	* @test
	*/
	public function Url_filter_punyencodes_IDNs()
	{
		$this->assertAttributeValidity(
			'url',
			'http://www.älypää.com',
			'http://www.xn--lyp-plada.com',
			true,
			array()
		);
	}

	/**
	* @test
	*/
	public function Url_filter_urlencodes_non_ASCII_chars()
	{
		$this->assertAttributeValidity(
			'url',
			'http://en.wikipedia.org/wiki/Matti_Nykänen',
			'http://en.wikipedia.org/wiki/Matti_Nyk%C3%A4nen',
			true,
			array()
		);
	}

	/**
	* @test
	* @depends Url_filter_urlencodes_non_ASCII_chars
	*/
	public function Url_filter_does_lose_parts_of_an_URL_that_contains_non_ASCII_chars()
	{
		$this->assertAttributeValidity(
			'url',
			'http://user:pass@en.wikipedia.org:80/wiki/Matti_Nykänen?foo&bar#baz',
			'http://user:pass@en.wikipedia.org:80/wiki/Matti_Nyk%C3%A4nen?foo&bar#baz',
			true,
			array()
		);
	}

	/**
	* @test
	* depends Url_filter_punyencodes_IDNs
	* depends Url_filter_urlencodes_non_ASCII_chars
	*/
	public function Url_filter_does_not_punyencode_credentials_that_match_an_IDN()
	{
		$this->assertAttributeValidity(
			'url',
			'http://älypää.com:älypää.com@älypää.com',
			'http://%C3%A4lyp%C3%A4%C3%A4.com:%C3%A4lyp%C3%A4%C3%A4.com@xn--lyp-plada.com',
			true,
			array()
		);
	}

	/**
	* @testdox Invalid URLs are rejected
	*/
	public function testInvalidUrlsAreRejected()
	{
		$this->assertAttributeIsInvalid('url', 'invalid');
	}

	/**
	* @testdox URLs with no host are rejected
	*/
	public function testUrlsWithNoHostAreRejected()
	{
		$this->assertAttributeIsInvalid('url', '/path/to/file');
	}

	/**
	* @testdox URLs with no path are accepted
	*/
	public function testUrlsWithNoPathAreAccepted()
	{
		$this->assertAttributeIsValid('url', 'http://www.example.com');
	}

	/**
	* @testdox URLs with no scheme are rejected by default
	*/
	public function testUrlsWithNoSchemeAreRejectedByDefault()
	{
		$this->assertAttributeIsInvalid('url', '//www.example.com');
	}

	/**
	* @testdox URLs with no scheme are validated using the default scheme set with ConfigBuilder::setDefaultScheme()
	*/
	public function testUrlsWithNoSchemeAreAcceptedIfConfigured()
	{
		$this->cb->setDefaultScheme('http');
		$this->assertAttributeIsValid('url', '//www.example.com');
	}


	/**
	* @testdox The default scheme used for validation does not appear in the filtered URL
	*/
	public function testDefaultSchemeDoesNotAppearInFilteredURL()
	{
		$this->cb->setDefaultScheme('http');
		$this->assertAttributeIsValid('url', '//www.example.com', '//www.example.com');
	}

	/**
	* @testdox Whitespace around URLs is removed
	* @depends testUrlsWithNoPathAreAccepted
	*/
	public function testWhitespaceIsRemovedFromURLs()
	{
		$this->assertAttributeIsValid('url', '  http://example.com  ', 'http://example.com');
	}

	public function testUrlFilterRejectsNotAllowedSchemes()
	{
		$this->assertAttributeIsInvalid(
			'url',
			'ftp://www.example.com',
			null,
			array(
				'error' => array(
					array(
						'msg'    => "URL scheme '%s' is not allowed",
						'params' => array('ftp')
					)
				)
			)
		);
	}

	public function testUrlFilterCanAcceptNonHttpSchemes()
	{
		$this->cb->allowScheme('ftp');

		$this->assertAttributeIsValid('url', 'ftp://www.example.com');
	}

	public function testUrlFilterRejectsDisallowedHost()
	{
		$this->cb->disallowHost('evil.example.com');

		$this->assertAttributeIsInvalid(
			'url',
			'http://evil.example.com',
			null,
			array(
				'error' => array(
					array(
						'msg'    => "URL host '%s' is not allowed",
						'params' => array('evil.example.com')
					)
				)
			)
		);
	}

	/**
	* @test
	*/
	public function Url_filter_rejects_disallowed_IDNs()
	{
		$this->cb->disallowHost('pаypal.com');

		$this->assertAttributeIsInvalid(
			'url',
			'http://www.pаypal.com',
			null,
			array(
				'error' => array(
					array(
						'msg'    => "URL host '%s' is not allowed",
						'params' => array('www.xn--pypal-4ve.com')
					)
				)
			)
		);
	}

	public function testUrlFilterRejectsDisallowedHostMask()
	{
		$this->cb->disallowHost('*.example.com');

		$this->assertAttributeIsInvalid(
			'url',
			'http://evil.example.com',
			null,
			array(
				'error' => array(
					array(
						'msg'    => "URL host '%s' is not allowed",
						'params' => array('evil.example.com')
					)
				)
			)
		);
	}

	public function testUrlFilterRejectsSubdomainsOfDisallowedHosts()
	{
		$this->cb->disallowHost('example.com');

		$this->assertAttributeIsInvalid(
			'url',
			'http://evil.example.com',
			null,
			array(
				'error' => array(
					array(
						'msg'    => "URL host '%s' is not allowed",
						'params' => array('evil.example.com')
					)
				)
			)
		);
	}

	public function testUrlFilterRejectsDisallowedTld()
	{
		$this->cb->disallowHost('*.com');

		$this->assertAttributeIsInvalid(
			'url',
			'http://evil.example.com',
			null,
			array(
				'error' => array(
					array(
						'msg'    => "URL host '%s' is not allowed",
						'params' => array('evil.example.com')
					)
				)
			)
		);
	}

	public function testUrlFilterDoesNotRejectHostOnPartialMatchOfADisallowedHost()
	{
		$this->cb->disallowHost('example.com');

		$this->assertAttributeIsValid('url', 'http://anotherexample.com');
	}

	public function testUrlFilterRejectsPseudoSchemes()
	{
		$this->assertAttributeIsInvalid('url', 'javascript:alert(\'@http://www.com\')');
	}

	/**
	* @test
	*/
	public function Url_filter_can_resolve_redirects_from_specified_hosts()
	{
		$this->cb->resolveRedirectsFrom('bit.ly');

		$this->fakeRedirect('http://bit.ly/2lkCBm', 'http://bit.ly/');

		$this->assertAttributeIsValid(
			'url',
			'http://bit.ly/2lkCBm',
			'http://bit.ly/',
			array(
				'debug' => array(
					array(
						'msg'    => 'Followed redirect from %1$s to %2$s',
						'params' => array('http://bit.ly/2lkCBm', 'http://bit.ly/')
					)
				)
			)
		);
	}

	/**
	* @test
	*/
	public function Url_filter_can_resolve_chained_redirects_from_specified_hosts()
	{
		$this->cb->resolveRedirectsFrom('bit.ly');

		$this->fakeRedirect('http://bit.ly/go', 'http://bit.ly/2lkCBm', 'http://bit.ly/');

		$this->assertAttributeIsValid(
			'url',
			'http://bit.ly/go',
			'http://bit.ly/',
			array(
				'debug' => array(
					array(
						'msg'    => 'Followed redirect from %1$s to %2$s',
						'params' => array('http://bit.ly/go', 'http://bit.ly/2lkCBm')
					),
					array(
						'msg'    => 'Followed redirect from %1$s to %2$s',
						'params' => array('http://bit.ly/2lkCBm', 'http://bit.ly/')
					),
					array(
						'msg'    => 'No Location: received from %s',
						'params' => array('http://bit.ly/')
					)
				)
			)
		);
	}

	/**
	* @test
	*/
	public function Url_filter_rejects_redirects_that_it_cannot_retrieve()
	{
		$this->cb->resolveRedirectsFrom('bit.ly');

		$this->fakeRedirect('http://bit.ly/2lkCBm', false);

		$this->assertAttributeIsInvalid(
			'url',
			'http://bit.ly/2lkCBm',
			null,
			array(
				'error' => array(
					array(
						'msg'    => 'Could not resolve %s',
						'params' => array('http://bit.ly/2lkCBm')
					)
				)
			)
		);
	}

	/**
	* @test
	*/
	public function Url_filter_rejects_redirect_that_redirects_to_itself()
	{
		$this->cb->resolveRedirectsFrom('bit.ly');

		$this->fakeRedirect('http://bit.ly/2lkCBm', 'http://bit.ly/2lkCBm');

		$this->assertAttributeIsInvalid(
			'url',
			'http://bit.ly/2lkCBm',
			null,
			array(
				'error' => array(
					array(
						'msg'    => 'Infinite recursion detected while following %s',
						'params' => array('http://bit.ly/2lkCBm')
					)
				)
			)
		);
	}

	/**
	* @test
	*/
	public function Url_filter_rejects_redirects_that_form_an_infinite_loop()
	{
		$this->cb->resolveRedirectsFrom('bit.ly');

		$this->fakeRedirect(
			'http://bit.ly/foo',
			'http://bit.ly/bar',
			'http://bit.ly/baz',
			'http://bit.ly/foo'
		);

		$this->assertAttributeIsInvalid(
			'url',
			'http://bit.ly/foo',
			null,
			array(
				'error' => array(
					array(
						'msg'    => 'Infinite recursion detected while following %s',
						'params' => array('http://bit.ly/foo')
					)
				)
			)
		);
	}

	/**
	* @test testUrlFilterRejectsDisallowedHost
	* @test Url_filter_can_resolve_redirects_from_specified_hosts
	*/
	public function Url_filter_rejects_disallowed_hosts_behind_a_redirect()
	{
		$this->cb->disallowHost('evil.tld');
		$this->cb->resolveRedirectsFrom('redirector.tld');

		$this->fakeRedirect('http://redirector.tld/abc', 'http://evil.tld');

		$this->assertAttributeIsInvalid(
			'url',
			'http://redirector.tld/abc',
			null,
			array(
				'error' => array(
					array(
						'msg'    => "URL host '%s' is not allowed",
						'params' => array('evil.tld')
					)
				)
			)
		);
	}

	public function testIdFilterAcceptsNumbers()
	{
		$this->assertAttributeIsValid('id', '123');
	}

	public function testIdFilterAcceptsLowercaseLetters()
	{
		$this->assertAttributeIsValid('id', 'abc');
	}

	public function testIdFilterAcceptsUppercaseLetters()
	{
		$this->assertAttributeIsValid('id', 'ABC');
	}

	public function testIdFilterAcceptsDashes()
	{
		$this->assertAttributeIsValid('id', '---');
	}

	public function testIdFilterAcceptsUnderscores()
	{
		$this->assertAttributeIsValid('id', '___');
	}

	public function testIdFilterRejectsSpaces()
	{
		$this->assertAttributeIsInvalid('id', '123 abc');
	}

	public function testIdentifierFilterIsAnAliasForTheIdFilter()
	{
		$this->assertAttributeIsValid('id', '-123abc_XYZ');
	}

	public function testColorFilterAcceptsRgbHexValues()
	{
		$this->assertAttributeIsValid('color', '#123abc');
	}

	public function testColorFilterRejectsInvalidRgbHexValues()
	{
		$this->assertAttributeIsInvalid('color', '#1234567');
	}

	public function testColorFilterAcceptsValuesMadeEntirelyOfLetters()
	{
		$this->assertAttributeIsValid('color', 'blueish');
	}

	public function testRangeFilterAllowsIntegersWithinRange()
	{
		$this->assertAttributeIsValid(
			array(
				'type' => 'range',
				'min'  => 5,
				'max'  => 10
			),
			8
		);
	}

	public function testRangeFilterAllowsNegativeIntegersWithinRange()
	{
		$this->assertAttributeIsValid(
			array(
				'type' => 'range',
				'min'  => -5,
				'max'  => 10
			),
			8
		);
	}

	public function testRangeFilterRejectsDecimalNumbers()
	{
		$this->assertAttributeIsInvalid(
			array(
				'type' => 'range',
				'min'  => 5,
				'max'  => 10
			),
			8.4
		);
	}

	public function testRangeFilterAdjustsValuesBelowRange()
	{
		$this->assertAttributeIsValid(
			array(
				'type' => 'range',
				'min'  => 5,
				'max'  => 10
			),
			3,
			5,
			array(
				'warning' => array(
					array(
						'msg' => 'Value outside of range, adjusted up to %d',
						'params' => array(5)
					)
				)
			)
		);
	}

	public function testRangeFilterAdjustsValuesAboveRange()
	{
		$this->assertAttributeIsValid(
			array(
				'type' => 'range',
				'min'  => 5,
				'max'  => 10
			),
			30,
			10,
			array(
				'warning' => array(
					array(
						'msg' => 'Value outside of range, adjusted down to %d',
						'params' => array(10)
					)
				)
			)
		);
	}

	public function testSimpletextFilterAcceptsLettersNumbersMinusAndPlusSignsDotsCommasUnderscoresAndSpaces()
	{
		$this->assertAttributeIsValid(
			'simpletext',
			'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+.,_ '
		);
	}

	public function testSimpletextFilterRejectsEverythingElse()
	{
		$allowed = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+.,_ ';

		for ($i = 32; $i <= 255; ++$i)
		{
			$c = chr($i);

			if (strpos($allowed, $c) === false)
			{
				$this->assertAttributeIsInvalid('simpletext', utf8_encode($c));
			}
		}
	}

	public function testRegexpFilterAcceptsContentThatMatches()
	{
		$this->assertAttributeIsValid(
			array('type' => 'regexp', 'regexp' => '#^[A-Z]$#D'),
			'J'
		);
	}

	public function testRegexpFilterRejectsContentThatDoesNotMatch()
	{
		$this->assertAttributeIsInvalid(
			array('type' => 'regexp', 'regexp' => '#^[A-Z]$#D'),
			'8'
		);
	}

	public function testRegexpFilterReplacesContentWithThePatternFoundInReplaceIfValid()
	{
		$this->assertAttributeIsValid(
			array('type' => 'regexp', 'regexp' => '#^([A-Z])$#D', 'replaceWith' => 'x$1x'),
			'J',
			'xJx'
		);
	}

	public function testRegexpFilterDoesNotReplaceContentWithThePatternFoundInReplaceIfInvalid()
	{
		$this->assertAttributeIsInvalid(
			array('type' => 'regexp', 'regexp' => '#^([A-Z])$#D', 'replaceWith' => 'x$1x'),
			'8'
		);
	}

	public function testRegexpFilterCorrectlyHandlesBackslashesInReplacePattern()
	{
		/**
		* Here we have the $2 token, followed by the literal "$2" followed by the $1 token
		* followed by the literal "\" (one backslash) followed by the $1 token followed by
		* the literal "\$1" (one backslash then dollar sign then 1) followed by the literal
		* "\\" (two backslashes)
		*
		* The result should be R$2L\L\$1\\
		*/
		$replace = '$2\\$2$1\\\\$1\\\\\\$1\\\\\\\\';
		$this->assertAttributeIsValid(
			array('type' => 'regexp', 'regexp' => '#^(L)(R)$#D', 'replaceWith' => $replace),
			'LR',
			'R$2L\\L\\$1\\\\'
		);
	}

	/**
	* @testdox Regexp filter's replaceWith option can use the ${1} syntax
	*/
	public function testRegexpFilterReplaceWithCurlyBrackets()
	{
		$this->assertAttributeIsValid(
			array('type' => 'regexp', 'regexp' => '#^(L)(R)$#D', 'replaceWith' => '${2}${1}'),
			'LR',
			'RL'
		);
	}

	public function testEmailFilterAcceptsValidEmails()
	{
		$this->assertAttributeIsValid('email', 'example@example.com');
	}

	public function testEmailFilterRejectsInvalidEmails()
	{
		$this->assertAttributeIsInvalid('email', 'example@example.com?');
	}

	public function testEmailFilterCanUrlencodeEveryCharacterOfAValidEmailIfForceUrlencodeIsOn()
	{
		$this->assertAttributeIsValid(
			array('type' => 'email', 'forceUrlencode' => true),
			'example@example.com',
			'%65%78%61%6d%70%6c%65%40%65%78%61%6d%70%6c%65%2e%63%6f%6d'
		);
	}

	public function testEmailFilterWillNotUrlencodeAnInvalidEmailEvenIfForceUrlencodeIsOn()
	{
		$this->assertAttributeIsInvalid(
			array('type' => 'email', 'forceUrlencode' => true),
			'example@invalid?'
		);
	}

	public function testUndefinedFilterRejectsEverything()
	{
		$this->assertAttributeIsInvalid(
			'whoknows',
			'foobar',
			null,
			array(
				'debug' => array(
					array(
						'msg'    => "Unknown filter '%s'",
						'params' => array('whoknows')
					)
				)
			)
		);
	}

	//==========================================================================
	// Attributes stuff
	//==========================================================================

	public function testAttributeNameIsAddedToLogEntriesWhenAvailable()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X');
		$this->cb->addTagAttribute('X', 'y', 'mytype');

		$this->cb->setFilter(
			'mytype',
			array(
				'params' => array('parser' => null),
				'callback' =>
					function($parser)
					{
						$parser->log('error', array('msg' => 'mytype error'));
						return false;
					}
			)
		);

		$this->cb->Canned->tags[] = array(
			'pos'   => 1,
			'len'   => 0,
			'name'  => 'X',
			'type'  => Parser::SELF_CLOSING_TAG,
			'attrs' => array('y' => 0)
		);

		$this->assertParsing(
			'text',
			'<pt>text</pt>',
			array(
				'error' => array(
					array(
						'msg' => 'mytype error',
						'pos' => 1,
						'tagName'  => 'X',
						'attrName' => 'y'
					)
				)
			)
		);
	}

	/**
	* @test
	*/
	public function Tag_level_preFilter_callback_receives_an_associative_array_of_attributes_which_gets_replaced_by_its_return_value()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X', array(
			'preFilter' => array(
				array(
					'callback' =>
						function($attrs)
						{
							// add an attribute
							$attrs['z'] = 'zval';

							return array_map('strtoupper', $attrs);
						}
				)
			)
		));
		$this->cb->addTagAttribute('X', 'x', 'text');
		$this->cb->addTagAttribute('X', 'y', 'text');
		$this->cb->addTagAttribute('X', 'z', 'text');

		$this->cb->Canned->tags[] = array(
			'pos'   => 0,
			'len'   => 1,
			'name'  => 'X',
			'type'  => Parser::SELF_CLOSING_TAG,
			'attrs' => array(
				'x' => 'xval',
				'y' => 'yval'
			)
		);

		$this->assertParsing(
			'.',
			'<rt><X x="XVAL" y="YVAL" z="ZVAL">.</X></rt>'
		);
	}

	/**
	* @test
	*/
	public function Tag_level_postFilter_callback_receives_an_associative_array_of_attributes_which_gets_replaced_by_its_return_value()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X', array(
			'postFilter' => array(
				array(
					'callback' =>
						function($attrs)
						{
							// add an attribute
							$attrs['z'] = 'zval';

							return array_map('strtoupper', $attrs);
						}
				)
			)
		));
		$this->cb->addTagAttribute('X', 'x', 'text');
		$this->cb->addTagAttribute('X', 'y', 'text');
		$this->cb->addTagAttribute('X', 'z', 'text');

		$this->cb->Canned->tags[] = array(
			'pos'   => 0,
			'len'   => 1,
			'name'  => 'X',
			'type'  => Parser::SELF_CLOSING_TAG,
			'attrs' => array(
				'x' => 'xval',
				'y' => 'yval'
			)
		);

		$this->assertParsing(
			'.',
			'<rt><X x="XVAL" y="YVAL" z="ZVAL">.</X></rt>'
		);
	}

	public function testCompoundAttributesAreSplitIfValidThenRemoved()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X');
		$this->cb->addTagAttribute('X', 'x', 'int', array('isRequired' => false));
		$this->cb->addTagAttribute('X', 'y', 'int', array('isRequired' => false));
		$this->cb->addTagAttribute('X', 'xy', 'compound', array(
			'regexp' => '#^(?P<x>[0-9]+),(?P<y>[0-9]+)$#D'
		));

		$this->cb->Canned->tags[] = array(
			'pos'   => 0,
			'len'   => 1,
			'name'  => 'X',
			'type'  => Parser::SELF_CLOSING_TAG,
			'attrs' => array('xy' => '123,456')
		);

		$this->assertParsing(
			'.',
			'<rt><X x="123" y="456">.</X></rt>'
		);
	}

	/**
	* @depends testCompoundAttributesAreSplitIfValidThenRemoved
	*/
	public function testCompoundAttributesDoNotOverwriteExistingValues()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X');
		$this->cb->addTagAttribute('X', 'x', 'int', array('isRequired' => false));
		$this->cb->addTagAttribute('X', 'y', 'int', array('isRequired' => false));
		$this->cb->addTagAttribute('X', 'xy', 'compound', array(
			'regexp' => '#^(?P<x>[0-9]+),(?P<y>[0-9]+)$#D'
		));

		$this->cb->Canned->tags[] = array(
			'pos'   => 0,
			'len'   => 1,
			'name'  => 'X',
			'type'  => Parser::SELF_CLOSING_TAG,
			'attrs' => array('xy' => '123,456', 'x' => 999)
		);

		$this->assertParsing(
			'.',
			'<rt><X x="999" y="456">.</X></rt>'
		);
	}

	public function testCompoundAttributesAreRemovedIfInvalid()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X');
		$this->cb->addTagAttribute('X', 'x', 'int', array('isRequired' => false));
		$this->cb->addTagAttribute('X', 'y', 'int', array('isRequired' => false));
		$this->cb->addTagAttribute('X', 'xy', 'compound', array(
			'regexp' => '#^(?P<x>[0-9]+),(?P<y>[0-9]+)$#D',
			'isRequired' => false
		));

		$this->cb->Canned->tags[] = array(
			'pos'   => 0,
			'len'   => 1,
			'name'  => 'X',
			'type'  => Parser::SELF_CLOSING_TAG,
			'attrs' => array('xy' => 'invalid')
		);

		$this->assertParsing(
			'.',
			'<rt><X>.</X></rt>'
		);
	}

	/**
	* @depends testCompoundAttributesAreRemovedIfInvalid
	*/
	public function testCompoundAttributesAreOptionalByDefault()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X');
		$this->cb->addTagAttribute('X', 'x', 'int', array('isRequired' => false));
		$this->cb->addTagAttribute('X', 'y', 'int', array('isRequired' => false));
		$this->cb->addTagAttribute('X', 'xy', 'compound', array(
			'regexp' => '#^(?P<x>[0-9]+),(?P<y>[0-9]+)$#D'
		));

		$this->cb->Canned->tags[] = array(
			'pos'   => 0,
			'len'   => 1,
			'name'  => 'X',
			'type'  => Parser::SELF_CLOSING_TAG,
			'attrs' => array('xy' => 'invalid')
		);

		$this->assertParsing(
			'.',
			'<rt><X>.</X></rt>'
		);
	}

	public function testInvalidAttributesUseTheirDefaultValueIfSet()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X');
		$this->cb->addTagAttribute('X', 'x', 'int', array('isRequired' => false, 'defaultValue' => 42));

		$this->cb->Canned->tags[] = array(
			'pos'   => 0,
			'len'   => 1,
			'name'  => 'X',
			'type'  => Parser::SELF_CLOSING_TAG,
			'attrs' => array('x' => 'invalid')
		);

		$this->assertParsing(
			'.',
			'<rt><X x="42">.</X></rt>',
			array(
				'error' => array(
					array(
						'msg'    => "Invalid attribute '%s'",
						'params' => array('x')
					)
				)
			)
		);
	}

	public function testMissingAttributesUseTheirDefaultValueIfSet()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X');
		$this->cb->addTagAttribute('X', 'x', 'int', array('isRequired' => false, 'defaultValue' => 42));

		$this->cb->Canned->tags[] = array(
			'pos'   => 0,
			'len'   => 1,
			'name'  => 'X',
			'type'  => Parser::SELF_CLOSING_TAG
		);

		$this->assertParsing(
			'.',
			'<rt><X x="42">.</X></rt>'
		);
	}

	/**
	* @test
	*/
	public function Attribute_value_is_replaced_by_the_return_value_of_the_attribute_preFilter_callbacks()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X');
		$this->cb->addTagAttribute('X', 'x', 'int', array('preFilter' => array(
			array('callback' => function($attrVal) { return 42; })
		)));

		$this->cb->Canned->tags[] = array(
			'pos'   => 0,
			'len'   => 1,
			'name'  => 'X',
			'type'  => Parser::SELF_CLOSING_TAG,
			'attrs' => array('x' => 'invalid')
		);

		$this->assertParsing(
			'.',
			'<rt><X x="42">.</X></rt>'
		);
	}

	/**
	* @test
	*/
	public function Attribute_value_is_replaced_by_the_return_value_of_the_attribute_postFilter_callbacks_even_if_it_makes_it_invalid()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X');
		$this->cb->addTagAttribute('X', 'x', 'int', array('postFilter' => array(
			array('callback' => function($attrVal) { return 'invalid'; })
		)));

		$this->cb->Canned->tags[] = array(
			'pos'   => 0,
			'len'   => 1,
			'name'  => 'X',
			'type'  => Parser::SELF_CLOSING_TAG,
			'attrs' => array('x' => 42)
		);

		$this->assertParsing(
			'.',
			'<rt><X x="invalid">.</X></rt>'
		);
	}

	//==========================================================================
	// Tags stuff
	//==========================================================================

	/**
	* @test
	*/
	public function getTagsConfig_returns_the_tags_config()
	{
		$this->cb->addTag('X');
		$this->assertArrayHasKey('X', $this->parser->getTagsConfig());
	}

	public function testPlainTextIsReturnedWithinPtTags()
	{
		$this->assertParsing('plain text', '<pt>plain text</pt>');
	}

	/**
	* @test
	*/
	public function Undefined_attributes_do_not_appear_in_XML()
	{
		$this->cb->BBCodes->addBBCode('x');
		$this->assertParsing(
			'[x unknown=123 /]',
			'<rt><X>[x unknown=123 /]</X></rt>'
		);
	}

	public function testOverlappingTagsAreRemoved()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		foreach (array(1, 2, 0, 4) as $pos)
		{
			$this->cb->addTag('X' . $pos);

			$this->cb->Canned->tags[] = array(
				'pos'  => $pos,
				'len'  => 2,
				'name' => 'X' . $pos,
				'type' => Parser::SELF_CLOSING_TAG
			);
		}

		$this->assertParsing(
			'012345',
			'<rt><X0>01</X0><X2>23</X2><X4>45</X4></rt>',
			array(
				'debug' => array(array(
					'msg' => 'Tag skipped',
					'pos' => 1,
					'tagName' => 'X1'
				))
			)
		);
	}

	protected function assertTagsOrder(array $tags, array $expectedOrder)
	{
		$r = new ReflectionMethod('s9e\\TextFormatter\\Parser', 'compareTags');
		$r->setAccessible(true);

		uasort($tags, function($a, $b) use ($r)
		{
			return $r->invokeArgs(null, array($a, $b));
		});

		$this->assertSame($expectedOrder, array_keys($tags));
	}

	/**
	* @testdox Tag sorting: tags are sorted by pos, descending
	*/
	public function testSort1()
	{
		$tags = array();

		foreach (array(2, 4, 3, 0) as $pos)
		{
			$tags[] = array(
				'id'   => count($tags),
				'name' => 'X',
				'pos'  => $pos,
				'len'  => 0,
				'type' => Parser::SELF_CLOSING_TAG
			);
		}

		$this->assertTagsOrder($tags, array(1, 2, 0, 3));
	}

	/**
	* @testdox Tag sorting: zero-width tags are ordered after wider tags
	*/
	public function testSort2()
	{
		$tags = array();

		foreach (array(0, 2) as $pos)
		{
			foreach (array(0, 1) as $len)
			{
				$tags[] = array(
					'id'   => count($tags),
					'name' => 'X',
					'pos'  => $pos,
					'len'  => $len,
					'type' => Parser::SELF_CLOSING_TAG
				);
			}
		}

		$this->assertTagsOrder($tags, array(3, 2, 1, 0));
	}

	/**
	* @testdox Tag sorting: zero-width end tags are ordered after zero-width start tags sharing the same position
	*/
	public function testSort3a()
	{
		$tags = array();

		foreach (array(0, 1) as $pos)
		{
			foreach (array(Parser::START_TAG, Parser::END_TAG) as $type)
			{
				$tags[] = array(
					'id'   => count($tags),
					'name' => 'X',
					'pos'  => $pos,
					'len'  => 0,
					'type' => $type
				);
			}
		}

		$this->assertTagsOrder($tags, array(2, 3, 0, 1));
	}

	/**
	* @testdox Tag sorting: zero-width end tags are ordered after zero-width self-closing tags sharing the same position
	*/
	public function testSort3b()
	{
		$tags = array();

		foreach (array(0, 1) as $pos)
		{
			foreach (array(Parser::SELF_CLOSING_TAG, Parser::END_TAG) as $type)
			{
				$tags[] = array(
					'id'   => count($tags),
					'name' => 'X',
					'pos'  => $pos,
					'len'  => 0,
					'type' => $type
				);
			}
		}

		$this->assertTagsOrder($tags, array(2, 3, 0, 1));
	}

	/**
	* @testdox Tag sorting: zero-width self-closing tags are ordered after zero-width start tags sharing the same position
	*/
	public function testSort3c()
	{
		$tags = array();

		foreach (array(0, 1) as $pos)
		{
			foreach (array(Parser::START_TAG, Parser::SELF_CLOSING_TAG) as $type)
			{
				$tags[] = array(
					'id'   => count($tags),
					'name' => 'X',
					'pos'  => $pos,
					'len'  => 0,
					'type' => $type
				);
			}
		}

		$this->assertTagsOrder($tags, array(2, 3, 0, 1));
	}

	/**
	* @testdox Tag sorting: tags sharing the same position and with a length greater than 0 are sorted by length ascending
	*/
	public function testSort4()
	{
		$tags = array();

		foreach (array(1, 3, 2) as $len)
		{
			$tags[] = array(
				'id'   => count($tags),
				'name' => 'X',
				'pos'  => 0,
				'len'  => $len,
				'type' => Parser::SELF_CLOSING_TAG
			);
		}

		$this->assertTagsOrder($tags, array(0, 2, 1));
	}

	/**
	* @testdox Tag sorting: if all else fails, tags are sorted by id descending
	*/
	public function testSort5()
	{
		$tags = array();

		foreach (array(1, 3, 2) as $id)
		{
			$tags[] = array(
				'id'   => $id,
				'name' => 'X',
				'pos'  => 0,
				'len'  => 1,
				'type' => Parser::SELF_CLOSING_TAG
			);
		}

		$this->assertTagsOrder($tags, array(1, 2, 0));
	}

	public function testTheNumberOfRegexpMatchesCanBeLimitedWithExtraMatchesIgnored()
	{
		include_once __DIR__ . '/includes/MultiRegexpConfig.php';
		$this->cb->loadPlugin('MultiRegexp', __NAMESPACE__ . '\\MultiRegexpConfig');

		$this->cb->MultiRegexp->regexpLimit = 3;
		$this->cb->MultiRegexp->regexpLimitAction = 'ignore';

		$this->assertParsing(
			'00 00',
			'<rt><X>0</X><X>0</X> <X>0</X>0</rt>',
			array(
				'debug' => array(array(
					'msg' => '%1$s limit exceeded. Only the first %2$s matches will be processed',
					'params' => array('MultiRegexp', 3)
				))
			)
		);
	}

	public function testTheNumberOfRegexpMatchesCanBeLimitedWithExtraMatchesIgnoredAndAWarning()
	{
		include_once __DIR__ . '/includes/MultiRegexpConfig.php';
		$this->cb->loadPlugin('MultiRegexp', __NAMESPACE__ . '\\MultiRegexpConfig');

		$this->cb->MultiRegexp->regexpLimit = 3;
		$this->cb->MultiRegexp->regexpLimitAction = 'warn';

		$this->assertParsing(
			'00 00',
			'<rt><X>0</X><X>0</X> <X>0</X>0</rt>',
			array(
				'warning' => array(array(
					'msg' => '%1$s limit exceeded. Only the first %2$s matches will be processed',
					'params' => array('MultiRegexp', 3)
				))
			)
		);
	}

	public function testTheNumberOfRegexpMatchesCanBeLimitedAcrossMultipleRegexpsWithExtraMatchesIgnored()
	{
		include_once __DIR__ . '/includes/MultiRegexpConfig.php';
		$this->cb->loadPlugin('MultiRegexp', __NAMESPACE__ . '\\MultiRegexpConfig');

		$this->cb->MultiRegexp->regexpLimit = 3;
		$this->cb->MultiRegexp->regexpLimitAction = 'ignore';

		$this->assertParsing(
			'00 11',
			'<rt><X>0</X><X>0</X> <X>1</X>1</rt>',
			array(
				'debug' => array(array(
					'msg' => '%1$s limit exceeded. Only the first %2$s matches will be processed',
					'params' => array('MultiRegexp', 3)
				))
			)
		);
	}

	/**
	* @expectedException RuntimeException
	* @expectedExceptionMessage MultiRegexp limit exceeded
	*/
	public function testTheNumberOfRegexpMatchesCanBeLimitedAndParsingAbortedIfLimitExceeded()
	{
		include_once __DIR__ . '/includes/MultiRegexpConfig.php';
		$this->cb->loadPlugin('MultiRegexp', __NAMESPACE__ . '\\MultiRegexpConfig');

		$this->cb->MultiRegexp->regexpLimit = 3;
		$this->cb->MultiRegexp->regexpLimitAction = 'abort';

		$this->parser->parse('00 00');
	}

	public function testUnknownTagsAreIgnored()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->Canned->tags = array(
			array(
				'pos'  => 0,
				'len'  => 1,
				'name' => 'X',
				'type' => Parser::START_TAG
			)
		);

		$this->assertParsing(
			'00 00',
			'<pt>00 00</pt>',
			array(
				'debug' => array(array(
					'msg' => 'Removed unknown tag %1$s from plugin %2$s',
					'params' => array('X', 'Canned')
				))
			)
		);
	}

	/**
	* @test
	*/
	public function Tags_nestingLimit_is_enforced()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X', array('nestingLimit' => 2));

		$text = 'SSSEEE';

		foreach (str_split($text, 1) as $pos => $c)
		{
			$this->cb->Canned->tags[] = array(
				'pos'   => $pos,
				'len'   => 1,
				'name'  => 'X',
				'type'  => ($c === 'S') ? Parser::START_TAG : Parser::END_TAG
			);
		}

		$this->assertParsing(
			$text,
			'<rt>
				<X>
					<st>S</st>
					<X>
						<st>S</st>'
						. 'S' .
						'<et>E</et>
					</X>
					<et>E</et>
				</X>'
			. 'E'
			. '</rt>'
		);
	}

	/**
	* @test
	*
	* This test exists to ensure that the parser correctly decrements the nesting counter when
	* tags are closed
	*/
	public function Tags_nestingLimit_does_not_incorrectly_count_siblings()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X', array('nestingLimit' => 2));

		$text = 'SSESESEE';

		foreach (str_split($text, 1) as $pos => $c)
		{
			$this->cb->Canned->tags[] = array(
				'pos'   => $pos,
				'len'   => 1,
				'name'  => 'X',
				'type'  => ($c === 'S') ? Parser::START_TAG : Parser::END_TAG
			);
		}

		$this->assertParsing(
			$text,
			'<rt>
				<X>
					<st>S</st>
					<X>
						<st>S</st>
						<et>E</et>
					</X>
					<X>
						<st>S</st>
						<et>E</et>
					</X>
					<X>
						<st>S</st>
						<et>E</et>
					</X>
					<et>E</et>
				</X>
			</rt>'
		);
	}

	/**
	* @test
	*/
	public function Tags_tagLimit_is_enforced()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X', array('tagLimit' => 2));

		foreach (array(0, 1, 2) as $pos)
		{
			$this->cb->Canned->tags[] = array(
				'pos'   => $pos,
				'len'   => 1,
				'name'  => 'X',
				'type'  => Parser::SELF_CLOSING_TAG
			);
		}

		$this->assertParsing(
			'012',
			'<rt><X>0</X><X>1</X>2</rt>'
		);
	}

	public function testZeroWidthTagsAreCorrectlyOuput()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X', array('tagLimit' => 2));

		foreach (array(0, 1, 2) as $pos)
		{
			$this->cb->Canned->tags[] = array(
				'pos'   => $pos,
				'len'   => 0,
				'name'  => 'X',
				'type'  => Parser::SELF_CLOSING_TAG
			);
		}

		$this->assertParsing(
			'012',
			'<rt><X />0<X />12</rt>'
		);
	}

	/**
	* @test
	*/
	public function Tags_left_open_get_closed_when_their_ancestor_gets_closed()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X');
		$this->cb->addTag('Y');
		$this->cb->addTag('Z');
		$this->cb->addTag('A');

		$this->cb->Canned->tags[] = array(
			'pos'   => 0,
			'len'   => 0,
			'name'  => 'X',
			'type'  => Parser::START_TAG
		);

		$this->cb->Canned->tags[] = array(
			'pos'   => 1,
			'len'   => 0,
			'name'  => 'Y',
			'type'  => Parser::START_TAG
		);

		$this->cb->Canned->tags[] = array(
			'pos'   => 2,
			'len'   => 0,
			'name'  => 'Z',
			'type'  => Parser::START_TAG
		);

		$this->cb->Canned->tags[] = array(
			'pos'   => 3,
			'len'   => 0,
			'name'  => 'X',
			'type'  => Parser::END_TAG
		);

		$this->cb->Canned->tags[] = array(
			'pos'   => 3,
			'len'   => 1,
			'name'  => 'A',
			'type'  => Parser::SELF_CLOSING_TAG
		);

		$this->assertParsing(
			'0123',
			'<rt><X>0<Y>1<Z>2</Z></Y></X><A>3</A></rt>'
		);
	}

	public function testTagsCanSpecifyAListOfTagsThatAreRequired()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X');

		$this->cb->Canned->tags[] = array(
			'pos'  => 0,
			'len'  => 1,
			'name' => 'X',
			'type' => Parser::SELF_CLOSING_TAG
		);

		$this->cb->Canned->tags[] = array(
			'pos'  => 1,
			'len'  => 1,
			'name' => 'X',
			'type' => Parser::SELF_CLOSING_TAG,
			'requires' => array(0)
		);

		$this->cb->Canned->tags[] = array(
			'pos'  => 2,
			'len'  => 1,
			'name' => 'X',
			'type' => Parser::SELF_CLOSING_TAG,
			'requires' => array(0, 1)
		);

		$this->assertParsing(
			'012',
			'<rt><X>0</X><X>1</X><X>2</X></rt>'
		);
	}

	/**
	* @test
	* @testdox Start tags only get closed by the right tagMate (same pluginName, same tagName, same differentiator if applicable)
	* @depends Tags_left_open_get_closed_when_their_ancestor_gets_closed
	*/
	public function Start_tags_only_get_closed_by_the_right_tagMate()
	{
		$this->cb->BBCodes->addBBCode('B');

		$this->assertParsing(
			'[b]x[b:123]x[/b]x',
			'<rt><B><st>[b]</st>x<B><st>[b:123]</st>x</B><et>[/b]</et></B>x</rt>'
		);
	}

	/**
	* @depends testOverlappingTagsAreRemoved
	*/
	public function testTagsCanSpecifyAListOfTagsThatAreRequiredAndBeSkippedIfAnyRequiredTagIsAbsent()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X');

		$this->cb->Canned->tags[] = array(
			'pos'  => 0,
			'len'  => 1,
			'name' => 'X',
			'type' => Parser::SELF_CLOSING_TAG
		);

		$this->cb->Canned->tags[] = array(
			'pos'  => 0,
			'len'  => 1,
			'name' => 'X',
			'type' => Parser::SELF_CLOSING_TAG,
			'requires' => array(0)
		);

		$this->cb->Canned->tags[] = array(
			'pos'  => 2,
			'len'  => 1,
			'name' => 'X',
			'type' => Parser::SELF_CLOSING_TAG,
			'requires' => array(0, 1)
		);

		$this->assertParsing(
			'012',
			'<rt><X>0</X>12</rt>'
		);
	}

	/**
	* @testdox HTML specs: <div><a> allows <div>
	*/
	public function testHTMLRules7a()
	{
		$this->cb->BBCodes->addBBCode('A', array('template' => '<a><xsl:apply-templates/></a>'));
		$this->cb->BBCodes->addBBCode('DIV', array(
			'template' => '<div><xsl:apply-templates/></div>'
		));

		$this->cb->addRulesFromHTML5Specs();

		$this->assertParsing(
			'[DIV][A][DIV][/DIV][/A][/DIV]',
			'<rt>
				<DIV>
					<st>[DIV]</st>
					<A>
						<st>[A]</st>
						<DIV>
							<st>[DIV]</st>
							<et>[/DIV]</et>
						</DIV>
						<et>[/A]</et>
					</A>
					<et>[/DIV]</et>
				</DIV>
			</rt>'
		);
	}

	/**
	* @testdox HTML specs: <span><a> denies <div>
	*/
	public function testHTMLRules7b()
	{
		$this->cb->BBCodes->addBBCode('A', array('template' => '<a><xsl:apply-templates/></a>'));
		$this->cb->BBCodes->addBBCode('DIV', array(
			'template' => '<div><xsl:apply-templates/></div>'
		));
		$this->cb->BBCodes->addBBCode('SPAN', array(
			'template' => '<span><xsl:apply-templates/></span>'
		));

		$this->cb->addRulesFromHTML5Specs();

		$this->assertParsing(
			'[SPAN][A][DIV][/DIV][/A][/SPAN]',
			'<rt>
				<SPAN>
					<st>[SPAN]</st>
					<A>
						<st>[A]</st>[DIV][/DIV]<et>[/A]</et>
					</A>
					<et>[/SPAN]</et>
				</SPAN>
			</rt>'
		);
	}

	//==========================================================================
	// Rules / content models
	//==========================================================================

	/**
	* @test
	*/
	public function Fulfilled_requireParent_rule_allows_tag()
	{
		$this->cb->BBCodes->addBBCode('a');
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->addTagRule('b', 'requireParent', 'a');

		$this->assertParsing(
			'[a][b]stuff[/b][/a]',
			'<rt><A><st>[a]</st><B><st>[b]</st>stuff<et>[/b]</et></B><et>[/a]</et></A></rt>'
		);
	}

	/**
	* @test
	* @depends Fulfilled_requireParent_rule_allows_tag
	*/
	public function requireParent_rule_with_multiple_targets_is_fulfilled_if_any_of_the_targets_is_the_parent()
	{
		$this->cb->BBCodes->addBBCode('a');
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->BBCodes->addBBCode('c');
		$this->cb->addTagRule('b', 'requireParent', 'a');
		$this->cb->addTagRule('b', 'requireParent', 'c');

		$this->assertParsing(
			'[a][b]stuff[/b][/a]',
			'<rt><A><st>[a]</st><B><st>[b]</st>stuff<et>[/b]</et></B><et>[/a]</et></A></rt>'
		);

		$this->assertParsing(
			'[c][b]stuff[/b][/c]',
			'<rt><C><st>[c]</st><B><st>[b]</st>stuff<et>[/b]</et></B><et>[/c]</et></C></rt>'
		);
	}

	/**
	* @test
	*/
	public function Fulfilled_requireParent_rule_allows_tag_despite_BBCode_suffix()
	{
		$this->cb->BBCodes->addBBCode('a');
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->addTagRule('b', 'requireParent', 'a');

		$this->assertParsing(
			'[a:123][b]stuff[/b][/a:123]',
			'<rt><A><st>[a:123]</st><B><st>[b]</st>stuff<et>[/b]</et></B><et>[/a:123]</et></A></rt>'
		);
	}

	/**
	* @test
	*/
	public function Unfulfilled_requireParent_rule_blocks_tag()
	{
		$this->cb->BBCodes->addBBCode('a');
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->addTagRule('b', 'requireParent', 'a');

		$this->assertParsing(
			'[b]stuff[/b]',
			'<pt>[b]stuff[/b]</pt>',
			array(
				'error' => array(
					array(
						'msg'     => 'Tag %1$s requires %2$s as parent',
						'params'  => array('B', 'A')
					)
				)
			)
		);
	}

	/**
	* @test
	*/
	public function Unfulfilled_requireParent_rule_blocks_tag_despite_ancestor()
	{
		$this->cb->BBCodes->addBBCode('a');
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->BBCodes->addBBCode('c');
		$this->cb->addTagRule('b', 'requireParent', 'a');

		$this->assertParsing(
			'[a][c][b]stuff[/b][/c][/a]',
			'<rt><A><st>[a]</st><C><st>[c]</st>[b]stuff[/b]<et>[/c]</et></C><et>[/a]</et></A></rt>',
			array(
				'error' => array(
					array(
						'msg'     => 'Tag %1$s requires %2$s as parent',
						'params'  => array('B', 'A')
					)
				)
			)
		);
	}

	/**
	* @test
	*/
	public function closeParent_rule_is_applied_to_matching_parent_tag()
	{
		$this->cb->BBCodes->addBBCode('p');
		$this->cb->addTagRule('p', 'closeParent', 'p');

		$this->assertParsing(
			'[p]one[p]two',
			'<rt><P><st>[p]</st>one</P><P><st>[p]</st>two</P></rt>'
		);
	}

	/**
	* @test
	*/
	public function closeParent_rule_is_not_applied_to_non_matching_parent_tag()
	{
		$this->cb->BBCodes->addBBCode('p');
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->addTagRule('p', 'closeParent', 'p');

		$this->assertParsing(
			'[b]bold[p]para[/p][/b]',
			'<rt><B><st>[b]</st>bold<P><st>[p]</st>para<et>[/p]</et></P><et>[/b]</et></B></rt>'
		);
	}

	/**
	* @test
	*/
	public function closeParent_rule_is_not_applied_to_ancestor_tag()
	{
		$this->cb->BBCodes->addBBCode('p');
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->addTagRule('p', 'closeParent', 'p');

		$this->assertParsing(
			'[p]one[b]bold[p]two[/p][/b][/p]',
			'<rt><P><st>[p]</st>one<B><st>[b]</st>bold<P><st>[p]</st>two<et>[/p]</et></P><et>[/b]</et></B><et>[/p]</et></P></rt>'
		);
	}

	/**
	* @test
	* @depends closeParent_rule_is_applied_to_matching_parent_tag
	*/
	public function closeParent_rule_is_applied_to_matching_parent_tag_with_identical_suffix()
	{
		$this->cb->BBCodes->addBBCode('p');
		$this->cb->addTagRule('p', 'closeParent', 'p');

		$this->assertParsing(
			'[p:123]one[p:123]two',
			'<rt><P><st>[p:123]</st>one</P><P><st>[p:123]</st>two</P></rt>'
		);
	}

	/**
	* @test
	* @depends closeParent_rule_is_applied_to_matching_parent_tag
	*/
	public function closeParent_rule_is_applied_to_matching_parent_tag_with_different_suffix()
	{
		$this->cb->BBCodes->addBBCode('p');
		$this->cb->addTagRule('p', 'closeParent', 'p');

		$this->assertParsing(
			'[p:123]one[p:456]two',
			'<rt><P><st>[p:123]</st>one</P><P><st>[p:456]</st>two</P></rt>'
		);
	}

	/**
	* @test
	* @depends Tags_nestingLimit_is_enforced
	* @depends closeParent_rule_is_applied_to_matching_parent_tag
	*/
	public function closeParent_rule_is_applied_before_nestingLimit_is_checked()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X', array('nestingLimit' => 1));

		$this->cb->addTagRule('X', 'closeParent', 'X');

		$this->cb->Canned->tags[] = array(
			'pos'   => 1,
			'len'   => 0,
			'name'  => 'X',
			'type'  => Parser::START_TAG
		);

		$this->cb->Canned->tags[] = array(
			'pos'   => 2,
			'len'   => 1,
			'name'  => 'X',
			'type'  => Parser::SELF_CLOSING_TAG
		);

		$this->assertParsing(
			'0123',
			'<rt>0<X>1</X><X>2</X>3</rt>'
		);
	}

	/**
	* @test
	*/
	public function closeAncestor_rule_is_applied_to_parent_tag()
	{
		$this->cb->BBCodes->addBBCode('p');
		$this->cb->addTagRule('p', 'closeAncestor', 'p');

		$this->assertParsing(
			'[p]one[p]two',
			'<rt><P><st>[p]</st>one</P><P><st>[p]</st>two</P></rt>'
		);
	}

	/**
	* @test
	* @depends Tags_left_open_get_closed_when_their_ancestor_gets_closed
	*/
	public function closeAncestor_rule_is_applied_to_ancestor_tag()
	{
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->BBCodes->addBBCode('p');
		$this->cb->addTagRule('p', 'closeAncestor', 'p');

		$this->assertParsing(
			'[p]one[b]bold[p]two',
			'<rt><P><st>[p]</st>one<B><st>[b]</st>bold</B></P><P><st>[p]</st>two</P></rt>'
		);
	}

	/**
	* @test
	* @depends closeAncestor_rule_is_applied_to_ancestor_tag
	*/
	public function closeAncestor_rule_is_applied_to_tag_with_identical_suffix()
	{
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->BBCodes->addBBCode('p');
		$this->cb->addTagRule('p', 'closeAncestor', 'p');

		$this->assertParsing(
			'[p:123]one[b]bold[p:123]two',
			'<rt><P><st>[p:123]</st>one<B><st>[b]</st>bold</B></P><P><st>[p:123]</st>two</P></rt>'
		);
	}

	/**
	* @test
	* @depends closeAncestor_rule_is_applied_to_ancestor_tag
	*/
	public function closeAncestor_rule_is_applied_to_tag_with_different_suffix()
	{
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->BBCodes->addBBCode('p');
		$this->cb->addTagRule('p', 'closeAncestor', 'p');

		$this->assertParsing(
			'[p:123]one[b]bold[p:456]two',
			'<rt><P><st>[p:123]</st>one<B><st>[b]</st>bold</B></P><P><st>[p:456]</st>two</P></rt>'
		);
	}

	/**
	* @test
	* @depends Tags_nestingLimit_is_enforced
	* @depends closeAncestor_rule_is_applied_to_parent_tag
	*/
	public function closeAncestor_rule_is_applied_before_nestingLimit_is_checked()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->addTag('X', array('nestingLimit' => 1));

		$this->cb->addTagRule('X', 'closeAncestor', 'X');

		$this->cb->Canned->tags[] = array(
			'pos'   => 1,
			'len'   => 0,
			'name'  => 'X',
			'type'  => Parser::START_TAG
		);

		$this->cb->Canned->tags[] = array(
			'pos'   => 2,
			'len'   => 1,
			'name'  => 'X',
			'type'  => Parser::SELF_CLOSING_TAG
		);

		$this->assertParsing(
			'0123',
			'<rt>0<X>1</X><X>2</X>3</rt>'
		);
	}

	/**
	* @test
	*/
	public function denyChild_rule_blocks_child_tag()
	{
		$this->cb->BBCodes->addBBCode('a');
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->addTagRule('a', 'denyChild', 'b');

		$this->assertParsing(
			'[a]..[b][/b]..[/a]',
			'<rt><A><st>[a]</st>..[b][/b]..<et>[/a]</et></A></rt>'
		);
	}

	/**
	* @test
	*/
	public function denyChild_rule_does_not_block_descendant_tag()
	{
		$this->cb->BBCodes->addBBCode('a');
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->BBCodes->addBBCode('c');
		$this->cb->addTagRule('a', 'denyChild', 'c');

		$this->assertParsing(
			'[a][b][c][/c][/b][/a]',
			'<rt>
				<A>
					<st>[a]</st>
					<B>
						<st>[b]</st>
						<C>
							<st>[c]</st>
							<et>[/c]</et>
						</C>
						<et>[/b]</et>
					</B>
					<et>[/a]</et>
				</A>
			</rt>'
		);
	}

	/**
	* @test
	*/
	public function denyDescendant_rule_blocks_child_tag()
	{
		$this->cb->BBCodes->addBBCode('a');
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->addTagRule('a', 'denyDescendant', 'b');

		$this->assertParsing(
			'[a]..[b][/b]..[/a]',
			'<rt><A><st>[a]</st>..[b][/b]..<et>[/a]</et></A></rt>'
		);
	}

	/**
	* @test
	*/
	public function denyDescendant_rule_blocks_descendant_tag()
	{
		$this->cb->BBCodes->addBBCode('a');
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->BBCodes->addBBCode('c');
		$this->cb->addTagRule('a', 'denyDescendant', 'c');

		$this->assertParsing(
			'[a][b][c][/c][/b][/a]',
			'<rt>
				<A>
					<st>[a]</st>
					<B><st>[b]</st>[c][/c]<et>[/b]</et></B>
					<et>[/a]</et>
				</A>
			</rt>'
		);
	}

	/**
	* @test
	*/
	public function allowChild_rule_allows_child_tag_despite_defaultChildRule_being_deny()
	{
		$this->cb->BBCodes->addBBCode('a', array('defaultChildRule' => 'deny'));
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->addTagRule('a', 'allowChild', 'b');

		$this->assertParsing(
			'[a][b][/b][/a]',
			'<rt><A><st>[a]</st><B><st>[b]</st><et>[/b]</et></B><et>[/a]</et></A></rt>'
		);
	}

	/**
	* @test
	*/
	public function requireAncestor_rule_is_fulfilled_by_parent()
	{
		$this->cb->BBCodes->addBBCode('a');
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->addTagRule('b', 'requireAncestor', 'a');

		$this->assertParsing(
			'[a][b][/b][/a]',
			'<rt><A><st>[a]</st><B><st>[b]</st><et>[/b]</et></B><et>[/a]</et></A></rt>'
		);
	}

	/**
	* @test
	* @depends requireAncestor_rule_is_fulfilled_by_parent
	*/
	public function requireAncestor_rule_is_fulfilled_by_parent_with_suffix()
	{
		$this->cb->BBCodes->addBBCode('a');
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->addTagRule('b', 'requireAncestor', 'a');

		$this->assertParsing(
			'[a:123][b][/b][/a:123]',
			'<rt><A><st>[a:123]</st><B><st>[b]</st><et>[/b]</et></B><et>[/a:123]</et></A></rt>'
		);
	}

	/**
	* @test
	*/
	public function requireAncestor_rule_is_fulfilled_by_ancestor()
	{
		$this->cb->BBCodes->addBBCode('a');
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->BBCodes->addBBCode('c');
		$this->cb->addTagRule('b', 'requireAncestor', 'a');

		$this->assertParsing(
			'[a][c][b][/b][/c][/a]',
			'<rt><A><st>[a]</st><C><st>[c]</st><B><st>[b]</st><et>[/b]</et></B><et>[/c]</et></C><et>[/a]</et></A></rt>'
		);
	}

	/**
	* @test
	* @depends requireAncestor_rule_is_fulfilled_by_ancestor
	*/
	public function requireAncestor_rule_is_fulfilled_by_ancestor_with_suffix()
	{
		$this->cb->BBCodes->addBBCode('a');
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->BBCodes->addBBCode('c');
		$this->cb->addTagRule('b', 'requireAncestor', 'a');

		$this->assertParsing(
			'[a:123][c][b][/b][/c][/a:123]',
			'<rt><A><st>[a:123]</st><C><st>[c]</st><B><st>[b]</st><et>[/b]</et></B><et>[/c]</et></C><et>[/a:123]</et></A></rt>'
		);
	}

	/**
	* @test
	* @depends requireAncestor_rule_is_fulfilled_by_parent_with_suffix
	*/
	public function requireAncestor_rule_with_multiple_targets_is_fulfilled_if_any_of_the_targets_is_an_ancestor()
	{
		$this->cb->BBCodes->addBBCode('a');
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->BBCodes->addBBCode('c');
		$this->cb->addTagRule('b', 'requireAncestor', 'a');
		$this->cb->addTagRule('b', 'requireAncestor', 'c');

		$this->assertParsing(
			'[a][b]stuff[/b][/a]',
			'<rt><A><st>[a]</st><B><st>[b]</st>stuff<et>[/b]</et></B><et>[/a]</et></A></rt>'
		);

		$this->assertParsing(
			'[c][b]stuff[/b][/c]',
			'<rt><C><st>[c]</st><B><st>[b]</st>stuff<et>[/b]</et></B><et>[/c]</et></C></rt>'
		);
	}

	/**
	* @test
	*/
	public function Unfulfilled_requireAncestor_rule_blocks_tag()
	{
		$this->cb->BBCodes->addBBCode('a');
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->addTagRule('b', 'requireAncestor', 'a');

		$this->assertParsing(
			'[b]stuff[/b]',
			'<pt>[b]stuff[/b]</pt>',
			array(
				'error' => array(
					array(
						'msg'     => 'Tag %1$s requires %2$s as ancestor',
						'params'  => array('B', 'A')
					)
				)
			)
		);
	}

	/**
	* @test
	*/
	public function reopenChild_rule_reopens_child_tag_if_it_was_closed_by_current_end_tag()
	{
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->BBCodes->addBBCode('i');
		$this->cb->addTagRule('b', 'reopenChild', 'i');

		$this->assertParsing(
			'[b][i]foo[/b] bar[/i]',
			'<rt><B><st>[b]</st><I><st>[i]</st>foo</I><et>[/b]</et></B><I> bar<et>[/i]</et></I></rt>'
		);
	}

	/**
	* @test
	* @depends reopenChild_rule_reopens_child_tag_if_it_was_closed_by_current_end_tag
	*/
	public function reopenChild_rule_does_not_reopen_child_tag_if_it_would_be_at_the_end_of_the_text()
	{
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->BBCodes->addBBCode('i');
		$this->cb->addTagRule('b', 'reopenChild', 'i');

		$this->assertParsing(
			'[b][i]foo[/b]',
			'<rt><B><st>[b]</st><I><st>[i]</st>foo</I><et>[/b]</et></B></rt>'
		);
	}

	/**
	* @test
	*/
	public function reopenChild_rule_reopens_all_descendants()
	{
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->BBCodes->addBBCode('i');
		$this->cb->BBCodes->addBBCode('u');
		$this->cb->addTagRule('b', 'reopenChild', 'i');
		$this->cb->addTagRule('b', 'reopenChild', 'u');

		$this->assertParsing(
			'[b][i][u]foo[/b] bar[/u] baz[/i]',
			'<rt><B><st>[b]</st><I><st>[i]</st><U><st>[u]</st>foo</U></I><et>[/b]</et></B><I><U> bar<et>[/u]</et></U> baz<et>[/i]</et></I></rt>'
		);
	}

	/**
	* @test
	*/
	public function reopenChild_rule_does_not_reopen_any_descendant_if_not_all_descendants_are_covered_by_a_reopenChild_rule()
	{
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->BBCodes->addBBCode('i');
		$this->cb->BBCodes->addBBCode('u');
		$this->cb->addTagRule('b', 'reopenChild', 'i');

		$this->assertParsing(
			'[b][i][u]foo[/b] bar[/u] baz[/i]',
			'<rt><B><st>[b]</st><I><st>[i]</st><U><st>[u]</st>foo</U></I><et>[/b]</et></B> bar[/u] baz[/i]</rt>'
		);
	}

	/**
	* @test
	* @depends reopenChild_rule_reopens_child_tag_if_it_was_closed_by_current_end_tag
	* @depends denyChild_rule_blocks_child_tag
	*/
	public function Tags_created_by_reopenChild_rule_respect_their_new_context()
	{
		$this->cb->BBCodes->addBBCode('b');
		$this->cb->BBCodes->addBBCode('i');
		$this->cb->BBCodes->addBBCode('u');
		$this->cb->addTagRule('b', 'reopenChild', 'i');
		$this->cb->addTagRule('u', 'denyChild', 'i');

		$this->assertParsing(
			'[u][b][i]foo[/b] bar[/i][/u]',
			'<rt><U><st>[u]</st><B><st>[b]</st><I><st>[i]</st>foo</I><et>[/b]</et></B> bar[/i]<et>[/u]</et></U></rt>'
		);
	}

	/**
	* @testdox Tags with option 'disallowAsRoot' are ignored if they don't have a parent
	*/
	public function testDisallowedAsRoot()
	{
		$this->cb->BBCodes->addBBCode('a');
		$this->cb->BBCodes->addBBCode('b', array('disallowAsRoot' => true));

		$this->assertParsing(
			'[b]stuff[/b]',
			'<pt>[b]stuff[/b]</pt>',
			array(
				'debug' => array(
					array(
						'msg'     => 'Tag %s is not allowed in this context',
						'params'  => array('B')
					)
				)
			)
		);
	}

	/**
	* @testdox Tags with option 'disallowAsRoot' are processed if they do have a parent
	*/
	public function testAllowedAsRoot()
	{
		$this->cb->BBCodes->addBBCode('a');
		$this->cb->BBCodes->addBBCode('b', array('disallowAsRoot' => true));

		$this->assertParsing(
			'[a][b]stuff[/b][/a]',
			'<rt><A><st>[a]</st><B><st>[b]</st>stuff<et>[/b]</et></B><et>[/a]</et></A></rt>'
		);
	}

	//==========================================================================
	// Whitespace trimming
	//==========================================================================

	/**
	* @dataProvider getWhitespaceTrimming
	*/
	public function testWhitespaceTrimmingWorks($options, $text, $expectedHtml, $expectedXml)
	{
		include_once __DIR__ . '/includes/WhitespaceConfig.php';

		$this->cb->loadPlugin(
			'Whitespace',
			__NAMESPACE__ . '\\WhitespaceConfig',
			array('options' => $options)
		);

		$actualXml = $this->parser->parse($text);
		$this->assertSame($expectedXml, $actualXml);

		$actualHtml = $this->renderer->render($expectedXml);
		$this->assertSame($expectedHtml, $actualHtml);
	}

	/**
	* @depends testOverlappingTagsAreRemoved
	* @depends testWhitespaceTrimmingWorks
	*/
	public function testWhitespaceTrimmingDoesNotCauseTagsToOverlap()
	{
		$this->cb->BBCodes->addBBCode('X', array(
			'trimBefore'   => true,
			'trimAfter'    => true,
			'ltrimContent' => true,
			'rtrimContent' => true,

			'template' => '<b><xsl:apply-templates /></b>'
		));

		$this->assertTransformation(
			'
				[X]
					[X]
						[X] [/X]
					[/X]
				[/X]
			',
			'<rt><i>
				</i><X><st>[X]</st><i>
					</i><X><st>[X]</st><i>
						</i><X><st>[X]</st><i> </i><et>[/X]</et></X><i>
					</i><et>[/X]</et></X><i>
				</i><et>[/X]</et></X><i>
			</i></rt>',
			'<b><b><b></b></b></b>'
		);
	}

	public function getWhitespaceTrimming()
	{
		/**
		* The elements, in order:
		*
		* - the BBCode options that are set for the [mark] BBCode
		* - text input
		* - HTML rendering
		* - intermediate representation in XML
		*
		* The tags' templates are set to recreate the tags as shown in the input, e.g. [b] will be
		* rendered as [b].
		*
		* In addition, a special plugin is used in order to use the string "tag" and " tagws " as
		* tags to study the interaction between the space consumed by a tag and the trimming option.
		*/
		return array(
			array(
				array('ltrimContent' => true),
				'[b] [mark] 1 [/mark] 2 [mark] 3 [/mark] [/b]',
				'[b] [mark]1 [/mark] 2 [mark]3 [/mark] [/b]',
				'<rt><B><st>[b]</st> <MARK><st>[mark]</st><i> </i>1 <et>[/mark]</et></MARK> 2 <MARK><st>[mark]</st><i> </i>3 <et>[/mark]</et></MARK> <et>[/b]</et></B></rt>'
			),
			array(
				array('rtrimContent' => true),
				'[b] [mark] 1 [/mark] 2 [mark] 3 [/mark] [/b]',
				'[b] [mark] 1[/mark] 2 [mark] 3[/mark] [/b]',
				'<rt><B><st>[b]</st> <MARK><st>[mark]</st> 1<i> </i><et>[/mark]</et></MARK> 2 <MARK><st>[mark]</st> 3<i> </i><et>[/mark]</et></MARK> <et>[/b]</et></B></rt>'
			),
			array(
				array('ltrimContent' => true, 'rtrimContent' => true),
				'[b] [mark] 1 [/mark] 2 [mark] 3 [/mark] [/b]',
				'[b] [mark]1[/mark] 2 [mark]3[/mark] [/b]',
				'<rt><B><st>[b]</st> <MARK><st>[mark]</st><i> </i>1<i> </i><et>[/mark]</et></MARK> 2 <MARK><st>[mark]</st><i> </i>3<i> </i><et>[/mark]</et></MARK> <et>[/b]</et></B></rt>'
			),
			array(
				array('trimBefore' => true),
				'[b] [mark] 1 [/mark] 2 [mark] 3 [/mark] [/b]',
				'[b][mark] 1 [/mark] 2[mark] 3 [/mark] [/b]',
				'<rt><B><st>[b]</st><i> </i><MARK><st>[mark]</st> 1 <et>[/mark]</et></MARK> 2<i> </i><MARK><st>[mark]</st> 3 <et>[/mark]</et></MARK> <et>[/b]</et></B></rt>'
			),
			array(
				array('trimAfter' => true),
				'[b] [mark] 1 [/mark] 2 [mark] 3 [/mark] [/b]',
				'[b] [mark] 1 [/mark]2 [mark] 3 [/mark][/b]',
				'<rt><B><st>[b]</st> <MARK><st>[mark]</st> 1 <et>[/mark]</et></MARK><i> </i>2 <MARK><st>[mark]</st> 3 <et>[/mark]</et></MARK><i> </i><et>[/b]</et></B></rt>'
			),
			array(
				array('trimBefore' => true, 'trimAfter' => true),
				'[b] [mark] 1 [/mark] 2 [mark] 3 [/mark] [/b]',
				'[b][mark] 1 [/mark]2[mark] 3 [/mark][/b]',
				'<rt><B><st>[b]</st><i> </i><MARK><st>[mark]</st> 1 <et>[/mark]</et></MARK><i> </i>2<i> </i><MARK><st>[mark]</st> 3 <et>[/mark]</et></MARK><i> </i><et>[/b]</et></B></rt>'
			),
			/**
			* In the following examples, the one space around "tagws" will not be removed. This is
			* because the plugin's parser defines it as part of the tag. Therefore, it makes sense
			* to actually preserve it
			*/
			array(
				array('ltrimContent' => true),
				'[b]  tagws  |  tagws  [/b]',
				'[b] [mark] tagws [/mark] | [mark] tagws [/mark] [/b]',
				'<rt><B><st>[b]</st> <MARK> tagws </MARK> | <MARK> tagws </MARK> <et>[/b]</et></B></rt>'
			),
			array(
				array('rtrimContent' => true),
				'[b]  tagws  |  tagws  [/b]',
				'[b] [mark] tagws [/mark] | [mark] tagws [/mark] [/b]',
				'<rt><B><st>[b]</st> <MARK> tagws </MARK> | <MARK> tagws </MARK> <et>[/b]</et></B></rt>'
			),
			array(
				array('trimBefore' => true),
				'[b]  tagws  |  tagws  [/b]',
				'[b][mark] tagws [/mark] |[mark] tagws [/mark] [/b]',
				'<rt><B><st>[b]</st><i> </i><MARK> tagws </MARK> |<i> </i><MARK> tagws </MARK> <et>[/b]</et></B></rt>'
			),
			array(
				array('trimAfter' => true),
				'[b]  tagws  |  tagws  [/b]',
				'[b] [mark] tagws [/mark]| [mark] tagws [/mark][/b]',
				'<rt><B><st>[b]</st> <MARK> tagws </MARK><i> </i>| <MARK> tagws </MARK><i> </i><et>[/b]</et></B></rt>'
			),
			array(
				array('trimBefore' => true),
				'[b] tag | tag [/b]',
				'[b][mark]tag[/mark] |[mark]tag[/mark] [/b]',
				'<rt><B><st>[b]</st><i> </i><MARK>tag</MARK> |<i> </i><MARK>tag</MARK> <et>[/b]</et></B></rt>'
			),
			array(
				array('trimAfter' => true),
				'[b] tag | tag [/b]',
				'[b] [mark]tag[/mark]| [mark]tag[/mark][/b]',
				'<rt><B><st>[b]</st> <MARK>tag</MARK><i> </i>| <MARK>tag</MARK><i> </i><et>[/b]</et></B></rt>'
			)
		);
	}

	public function testAcceptsNamespacedTags()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->registerNamespace('foo', 'urn:foo');
		$this->cb->addTag('foo:BAR');

		$this->cb->Canned->tags[] = array(
			'pos'   => 0,
			'len'   => 1,
			'name'  => 'foo:BAR',
			'type'  => Parser::SELF_CLOSING_TAG
		);

		$this->assertContains(
			'<foo:BAR>',
			$this->parser->parse('X')
		);
	}

	public function testOutputsNamespaceDeclarationsAtTheRoot()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->registerNamespace('foo', 'urn:foo');
		$this->cb->addTag('foo:BAR');

		$this->cb->Canned->tags[] = array(
			'pos'   => 0,
			'len'   => 1,
			'name'  => 'foo:BAR',
			'type'  => Parser::SELF_CLOSING_TAG
		);

		$this->assertParsing(
			'X',
			'<rt xmlns:foo="urn:foo"><foo:BAR>X</foo:BAR></rt>'
		);
	}

	/**
	* @testdox Namespaced tags are case-sensitive
	*/
	public function testNamespacedTagsAreCaseSensitive()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->registerNamespace('foo', 'urn:foo');
		$this->cb->addTag('foo:bar');

		$this->cb->Canned->tags[] = array(
			'pos'   => 0,
			'len'   => 1,
			'name'  => 'foo:BAR',
			'type'  => Parser::SELF_CLOSING_TAG
		);

		$this->assertParsing(
			'X',
			'<pt>X</pt>'
		);
	}

	public function testTheCaseOfNamespacedTagsIsPreserved()
	{
		include_once __DIR__ . '/includes/CannedConfig.php';
		$this->cb->loadPlugin('Canned', __NAMESPACE__ . '\\CannedConfig');

		$this->cb->registerNamespace('foo', 'urn:foo');
		$this->cb->addTag('foo:bar');

		$this->cb->Canned->tags[] = array(
			'pos'   => 0,
			'len'   => 1,
			'name'  => 'foo:bar',
			'type'  => Parser::SELF_CLOSING_TAG
		);

		$this->assertParsing(
			'X',
			'<rt xmlns:foo="urn:foo"><foo:bar>X</foo:bar></rt>'
		);
	}
}

class FakeRedirect
{
	static public $redirectTo = array();

	public function stream_open($url)
	{
		if (isset(self::$redirectTo[$url]))
		{
			if (self::$redirectTo[$url] === false)
			{
				return false;
			}

			$this->{'0'} = 'Location: ' . self::$redirectTo[$url];
		}

		return true;
	}

	public function stream_stat()
	{
		return false;
	}

	public function stream_read()
	{
		return '';
	}

	public function stream_eof()
	{
		return true;
	}
}